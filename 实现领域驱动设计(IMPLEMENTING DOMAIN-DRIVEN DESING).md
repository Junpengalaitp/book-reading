### 第一章 DDD入门
* 为什么我们需要DDD
  * 使领域专家和开发者在一起工作，这样开发出的软件能够准确地传达业务规则。
  * 可以帮助业务人员自我提高。
  * 确保软件知识并不是只掌握在少数人手中。
  * 在领域专家，开发者之间不需要翻译。
  * 设计就是代码，代码就是设计。
  * DDD同时提供了战略设计和战术设计两种方式。
    * 战略设计帮助我们理解哪些软件资产、人力投入是最重要的
    * 战术设计帮助我们创建DDD模型中各个部件
* 难以捉摸的业务价值
  * 开发过程中，最大的鸿沟之一就是领域专家和开发者之间
  * 软件不能完全反映出领域专家的思维模型，随着时间的推移，这种鸿沟将增加软件的开发成本
  * 在复杂性问题上犯错时，很难轻易改正

* 如何DDD
  * 掌握通用语言
    * 同时绘制物理模型图和概念模型图，并标以名字和行为
    * 创建一个包含简单定义的术语表，或者文档
    * 团队成员间互相检查成果
* 使用DDD的业务价值
  * 得到一个非常有用的领域模型
  * 业务得到更准确的定义和理解
  * 领域专家可以为软件设计做出贡献
  * 更好的用户体验
  * 清晰的模型边界
  * 更好的企业架构
  * 敏捷、迭代式和持续建模
  * 使用战略和战术新工具

* 实施DDD的挑战
  * 为创建通用语言腾出时间和精力
  * 持续地将领域专家引入项目
  * 改变开发者对领域的思考方式

### 第二章 领域、子域和限界上下文
* 领域
  * 一个组织所做的事情以及其中所包含的一切
* 子域
  * 限界上下文
  * 核心域：业务成功的主要因素，应给予最多的资源
  * 支撑子域：界限上下文对应业务某些重要方面，但却不是核心
  * 通用自域：被用于整个业务系统的子域
* 战略设计的重要性
* 存在问题空间
  * 领域的一部分，对问题空间的开发将产生一个新的核心域
  * 评估应同时考虑已有子域和额外所需子域
  * 核心域和其他子域的组合
* 解决方案空间
  * 包括一个或多个界限上下文，一组特定的软件模型
  * 一个特定的解决方案，通过软件的方式
* 存在问题空间评估
  * 这个战略核心域的名字是什么，目标是什么？
  * 这个战略核心域中包含哪些概念？
  * 这个核心的支撑子域和通用子域是什么？
  * 如何安排项目人员？
  * 你能组建出一支合适的团队吗？
* 解决方案空间评估
  * 哪些软件资产是存在的，可以重用吗？
  * 哪些软件资产是需要创建的，或者从别处获得？
  * 这些资产是如何集成在一起的？
  * 还需要什么样的集成？
  * 假设已经有了现有资产和需要创建的资产，还需要做些什么？
  * 核心域和那些支撑项目的成功几率如何？会不会出现由于其中一个失败而导致整个项目失败的可能？
  * 在哪些地方我们使用了完全不同的术语？
  * 限界上下文之间在哪些地方存在概念重叠？
  * 这些重叠的概念在不同的限界上下文中是如何映射和翻译的？
  * 哪些限界上下文包含了核心域中的概念，使用了哪些[Evans]中的战术模式？

* 理解限界上下文
  * 一个显示的边界，领域模型便存在于这个边界之内。
  * 充满语义，通用语言中的所有术语和词组都有特定的含义，模型需要准确地反映通用语言
* 限界上下文的大小
  * 足够表达它所对应的整套通用语言
  * 核心领域之外的概念不应该包含在限界上下文之中
  * 不能遗漏任何重要的概念
* 与技术组件保持一致

### 上下文映射图（Context Map）
* 产品和组织关系
  * 合作关系(Partnership)
    * 两个界限上下文要么一起成功，要么一起失败
    * 两个团队需要协同开发和集成管理，在接口的演化上进行合作以同时满足两个系统的需求
    * 为相关联的功能制定计划表，确保这些功能在同一个发布中完成
  * 共享内核(Shared Kernel)
    * 对模型和代码的共享将产生一种紧密的依赖性
    * 这种依赖性可好可坏
    * 共享的模型需要指定显式边界，并保持共享内核的小型化
    * 具有特殊的状态，在没有与另一个团队协商的情况下，不能改变
  * 生产者-消费者开发(Customer-Supplier Development)
    * 在上游团队的计划中，应该顾及到下游团队的需求
  * 遵奉者(Conformist)
    * 上游团队没有动力提供下游团队所需
    * 下游团队只能盲目地使用上游团队的模型
  * 防腐层(Anticorruption Layer)
    * 下游客户需要根据自己的领域模型创建一个单独的层，作为上游系统的代理像你的系统提供功能。
  * 开放主机服务(Open Host Service)
    * 定义一种协议，让你的子系统通过该协议来访问你的服务。
    * 公开协议，任何想和你集成的人都可使用该协议。
    * 有新的集成需求时，应该对协议进行改进和扩展。
  * 发布语言(Published Language)
    * 在两个限界上下文中翻译模型需要一种公用的语言
  * 另谋他路(SeparateWay)
    * 在确定需求时，我们应该做到坚决彻底。
    * 如果两套功能没有显著的关系，它们是可以完全解耦的。
    * 集成是昂贵的，带来的好处也不大
  * 大泥球(Big Ball of Mud)
    * 已有系统中经常有混杂在一起的模型，它们之间的边界是非常模糊的。
    * 应该为整个系统绘制一个边界，然后将其归纳在大泥球范围之列。
    * 在这个边界内，不要尝试用复杂的建模手段来化解问题。

### 第四章 架构
* 分层式架构
  * 每层只能与位于其下方的层发生耦合
    * 严格分层架构：只与直接位于其下方的层发生耦合
    * 松散分层架构：任意上层与任意下层耦合
* 六边形架构
  * 依赖注入
  * 不同的客户通过平等的方式与系统交互
* 面向服务架构(SOA)
  * 服务契约：通过契约文档，服务阐述自身的目的和功能
  * 松耦合：服务将依赖关系最小化
  * 服务抽象：服务只发布契约，向客户隐藏内部逻辑
  * 服务重用性：一种服务可以被其他服务所重用
  * 服务自治性：服务自行控制环境和资源以保持独立性，这有助于保持服务的一致性和可靠性
  * 服务无状态性：服务负责消费方的状态管理，这不能与服务的自治性冲突
  * 服务可发现性：客户可以通过元数据来查找服务和理解服务
  * 一种服务可以由其他的服务组合而成，而不管其他服务的大小和复杂性如何
* 事件驱动架构
  * 使用消息中间件传递事件

### 第五章 实体
* 为什么使用实体
  * 唯一标识
    * 用户提供唯一标识
    * 应用程序生成唯一标识
      * UUID
      * GUID
    * 持久化机制生成唯一标识
    * 另一个限界上下文提供唯一标识

### 第六章 值对象
* 特征
  * 度量或描述了领域中的一件东西
  * 可作为不变量
  * 将不同的相关属性组合成一个概念整体
  * 当度量和描述改变时，可以用另一个值对象予以替换
  * 可以和其他值对象进行相等性比较
  * 它不会对协作对象造成副作用

### 第七章 领域服务
* 什么是领域服务
  * 处理业务逻辑
* 确定是否需要一个领域服务
* 建模领域服务
  * 是否需要一个独立接口

### 第八章 领域事件
* 何时/为什么使用领域事件
  * 当...
  * 如果发生...
  * 当...的时候，请通知我
  * 发生...时
* 建模领域事件
  * 根据限界上下文的通用语言来命名事件及其属性
  * 如果由聚合上的命令操作产生，根据该操作的方法的名字来命名领域事件
  * 一个事件戳来记录事件发生的时间
  * 导致领域事件产生的原因
  * 创建具有聚合特征的领域事件
  * 身份标识
  * 从领域模型中发布领域事件
    * 发布-订阅模式
* 向远程限界上下文发布领域事件
  * 消息设施的一致性
    * 领域模型和消息设施共享持久化存储（比如，数据源）。对模型的修改和对事件的提交发生在同一个本地事务中。这种方式的优点在于性能很高，缺点是消息系统的存储区域（比如数据库表）必须和领域模型位于同一个数据库中。
    * 领域模型的持久化存储和消息持久化存储由全局的XA事务（两阶段提交）所控制。优点是在于模型和消息所使用的持久化存储可以分开。缺点是全局事务需要额外的支持。全局事务成本很高，性能很差。
    * 在领域模型的持久化存储中，创建一个特殊的存储区域（例如一张数据表），该区域用于存储领域事件。
  * 自治服务和系统  
    * 一个设计良好的业务服务
    * 在企业范围之内，相互独立完成各自的功能
  * 容许时延
* 事件存储
  * 将事件存储作为一个消息队列来使用，作用是将所有的领域事件通过消息设施发布出去
  * 将相同的事件存储用于基于REST的事件通知
  * 检查由模型的命令方法所产生的所有结果的历史记录，可用于跟踪BUG
  * 使用事件存储中的数据来进行业务预测和分析
  * 当从资源库中获取一个聚合实例时，使用事件来重建该聚合实例
  * 撤销对聚合的操作
* 通过消息中间件发布事件通知

### 第九章 模块
* 通过模块完成设计
  * 模块应该和领域概念保持协调一致
  * 根据通用语言来命名模块
  * 不要机械式的根据通用的组件类型和模式来创建模块
  * 设计松耦合的模块
  * 当同层模块间出现耦合时，我们应该杜绝循环依赖
  * 在父子模块间放松原则
  * 不要将模块设计成一个静态的概念，而是与模型中的对象一道进行建模

### 第十章 聚合
  * 将实体和值对象在一致性边界中组成聚合
    * 原则：在一致性边界之内建模真正的不变条件
    * 原则：设计小聚合
    * 原则：通过唯一标示引用其他聚合
    * 原则：在边界之外使用最终一致性
  * 实现
    * 创建具有唯一标识的根实体
    * 优先使用值对象
    * 迪米特法则(Law of Demeter)
      * 任何对象的任何方法只能调用以下对象中的方法
        * 该对象自身
        * 所传入的参数对象
        * 它所创建的对象
        * 自身所包含的其他对象，并且对那些对象有直接访问权
      * 告诉而非询问法则
        * 一个对象不应该被告知如何执行操作
        * 客户端对象不应该先询问服务对象，然后再根据询问结果调用服务中的方法，而是应该通过调用服务对象的公共接口方式来“告诉”服务对象所要执行的操作。

### 第十一章 工厂
* 将创建复杂对象和聚合的职责分配给一个单独的对象，该对象本身不承担领域模型中的职责，但仍然是领域设计的一部分

### 第十二章 资源库
* 面向集合资源库
  * 一个资源库应该模拟一个Set集合，无论采用什么类型的持久化机制，我们都不应该允许多次添加同一个聚合实例。
  * 当从资源库获取一个对象并对其进行修改时，我们并不需要重新保存该对象到资源库中
* 面向持久化资源库
  * 新建或修改现有对象时，都必须显式地调用put()方法
* 管理事务
  * 事务的管理绝不应该放在领域模型和领域层中，因为与领域模型相关的操作都是细粒度的，以致于无法用于管理事务。
  * 事务应该放在应用层中，然后为每个主要的用例创建一个门面。门面中的业务方法通常都是粗粒度的，常见的情况是每一个用例流对应一个业务方法。

### 第十三章 集成限界上下文
* 分布式系统之间存在的根本性区别
  * 网络是不可靠的
  * 总是存在时间延迟
  * 带宽是有限的
  * 不要假设网络是安全的
  * 网络拓扑结构将发生变化
  * 知识和政策在多个管理员之间传播
  * 网络传输是有成本的
  * 网络是异构的
* 通过REST资源集成限界上下文
* 通过消息集成限界上下文

