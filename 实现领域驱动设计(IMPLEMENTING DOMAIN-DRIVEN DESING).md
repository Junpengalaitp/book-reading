### 第一章 DDD入门
* 为什么我们需要DDD
  * 使领域专家和开发者在一起工作，这样开发出的软件能够准确地传达业务规则。
  * 可以帮助业务人员自我提高。
  * 确保软件知识并不是只掌握在少数人手中。
  * 在领域专家，开发者之间不需要翻译。
  * 设计就是代码，代码就是设计。
  * DDD同时提供了战略设计和战术设计两种方式。
    * 战略设计帮助我们理解哪些软件资产、人力投入是最重要的
    * 战术设计帮助我们创建DDD模型中各个部件
* 难以捉摸的业务价值
  * 开发过程中，最大的鸿沟之一就是领域专家和开发者之间
  * 软件不能完全反映出领域专家的思维模型，随着时间的推移，这种鸿沟将增加软件的开发成本
  * 在复杂性问题上犯错时，很难轻易改正

* 如何DDD
  * 掌握通用语言
    * 同时绘制物理模型图和概念模型图，并标以名字和行为
    * 创建一个包含简单定义的术语表，或者文档
    * 团队成员间互相检查成果
* 使用DDD的业务价值
  * 得到一个非常有用的领域模型
  * 业务得到更准确的定义和理解
  * 领域专家可以为软件设计做出贡献
  * 更好的用户体验
  * 清晰的模型边界
  * 更好的企业架构
  * 敏捷、迭代式和持续建模
  * 使用战略和战术新工具

* 实施DDD的挑战
  * 为创建通用语言腾出时间和精力
  * 持续地将领域专家引入项目
  * 改变开发者对领域的思考方式

### 第二章 领域、子域和限界上下文
* 领域
  * 一个组织所做的事情以及其中所包含的一切
* 子域
  * 限界上下文
  * 核心域：业务成功的主要因素，应给予最多的资源
  * 支撑子域：界限上下文对应业务某些重要方面，但却不是核心
  * 通用自域：被用于整个业务系统的子域
* 战略设计的重要性
* 存在问题空间
  * 领域的一部分，对问题空间的开发将产生一个新的核心域
  * 评估应同时考虑已有子域和额外所需子域
  * 核心域和其他子域的组合
* 解决方案空间
  * 包括一个或多个界限上下文，一组特定的软件模型
  * 一个特定的解决方案，通过软件的方式
* 存在问题空间评估
  * 这个战略核心域的名字是什么，目标是什么？
  * 这个战略核心域中包含哪些概念？
  * 这个核心的支撑子域和通用子域是什么？
  * 如何安排项目人员？
  * 你能组建出一支合适的团队吗？
* 解决方案空间评估
  * 哪些软件资产是存在的，可以重用吗？
  * 哪些软件资产是需要创建的，或者从别处获得？
  * 这些资产是如何集成在一起的？
  * 还需要什么样的集成？
  * 假设已经有了现有资产和需要创建的资产，还需要做些什么？
  * 核心域和那些支撑项目的成功几率如何？会不会出现由于其中一个失败而导致整个项目失败的可能？
  * 在哪些地方我们使用了完全不同的术语？
  * 限界上下文之间在哪些地方存在概念重叠？
  * 这些重叠的概念在不同的限界上下文中是如何映射和翻译的？
  * 哪些限界上下文包含了核心域中的概念，使用了哪些[Evans]中的战术模式？

* 理解限界上下文
  * 一个显示的边界，领域模型便存在于这个边界之内。
  * 充满语义，通用语言中的所有术语和词组都有特定的含义，模型需要准确地反映通用语言
* 限界上下文的大小
  * 足够表达它所对应的整套通用语言
  * 核心领域之外的概念不应该包含在限界上下文之中
  * 不能遗漏任何重要的概念
* 与技术组件保持一致

### 上下文映射图（Context Map）
* 产品和组织关系
  * 合作关系(Partnership)
    * 两个界限上下文要么一起成功，要么一起失败
    * 两个团队需要协同开发和集成管理，在接口的演化上进行合作以同时满足两个系统的需求
    * 为相关联的功能制定计划表，确保这些功能在同一个发布中完成
  * 共享内核(Shared Kernel)
    * 对模型和代码的共享将产生一种紧密的依赖性
    * 这种依赖性可好可坏
    * 共享的模型需要指定显式边界，并保持共享内核的小型化
    * 具有特殊的状态，在没有与另一个团队协商的情况下，不能改变
  * 生产者-消费者开发(Customer-Supplier Development)
    * 在上游团队的计划中，应该顾及到下游团队的需求
  * 遵奉者(Conformist)
    * 上游团队没有动力提供下游团队所需
    * 下游团队只能盲目地使用上游团队的模型
  * 防腐层(Anticorruption Layer)
    * 下游客户需要根据自己的领域模型创建一个单独的层，作为上游系统的代理像你的系统提供功能。
  * 开放主机服务(Open Host Service)
    * 定义一种协议，让你的子系统通过该协议来访问你的服务。
    * 公开协议，任何想和你集成的人都可使用该协议。
    * 有新的集成需求时，应该对协议进行改进和扩展。
  * 发布语言(Published Language)
    * 在两个限界上下文中翻译模型需要一种公用的语言
  * 另谋他路(SeparateWay)
    * 在确定需求时，我们应该做到坚决彻底。
    * 如果两套功能没有显著的关系，它们是可以完全解耦的。
    * 集成是昂贵的，带来的好处也不大
  * 大泥球(Big Ball of Mud)
    * 已有系统中经常有混杂在一起的模型，它们之间的边界是非常模糊的。
    * 应该为整个系统绘制一个边界，然后将其归纳在大泥球范围之列。
    * 在这个边界内，不要尝试用复杂的建模手段来化解问题。

### 第四章 架构
* 分层式架构
  * 每层只能与位于其下方的层发生耦合
    * 严格分层架构：只与直接位于其下方的层发生耦合
    * 松散分层架构：任意上层与任意下层耦合
* 六边形架构
  * 依赖注入
  * 不同的客户通过平等的方式与系统交互
* 面向服务架构(SOA)
  * 服务契约：通过契约文档，服务阐述自身的目的和功能
  * 松耦合：服务将依赖关系最小化
  * 服务抽象：服务只发布契约，向客户隐藏内部逻辑
  * 服务重用性：一种服务可以被其他服务所重用
  * 服务自治性：服务自行控制环境和资源以保持独立性，这有助于保持服务的一致性和可靠性
  * 服务无状态性：服务负责消费方的状态管理，这不能与服务的自治性冲突
  * 服务可发现性：客户可以通过元数据来查找服务和理解服务
  * 一种服务可以由其他的服务组合而成，而不管其他服务的大小和复杂性如何
* 事件驱动架构
  * 使用消息中间件传递事件

### 第五章 实体
* 为什么使用实体
  * 唯一标识
    * 用户提供唯一标识
    * 应用程序生成唯一标识
      * UUID
      * GUID
    * 持久化机制生成唯一标识
    * 另一个限界上下文提供唯一标识