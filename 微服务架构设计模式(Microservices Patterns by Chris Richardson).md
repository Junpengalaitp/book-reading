### 第一章 逃离单体地狱
* 迈向单体地狱的漫长旅程
  * 早期单体架构的好处
    * 应用开发很简单
    * 易于大规模修改
    * 测试相对简单直观
    * 部署简单明了
    * 横向扩展容易
  * 单体地狱
    * 过度的复杂性吓退开发者
    * 开发速度缓慢
    * 开发到部署周期长，容易出问题
    * 难以扩展
    * 交付可靠难以达成
    * 长期依赖过时的技术栈
* 微服务
  * 好处
    * 使大型的复杂应用程序可以持续交付部署
    * 每个服务都相对较小并容易维护
    * 服务可以独立部署和扩展
    * 实现团队自治
    * 容易实验和采纳新技术
    * 更好的容错性
  * 弊端
    * 服务的拆分和定义是一项挑战
    * 分布式带来的复杂性
    * 部署跨越多个服务的功能需要谨慎
    * 开发者需要思考在什么阶段使用微服务架构

### 第二章 服务的拆分策略
* 微服务架构到底是什么
  * 软件架构：一种抽象结构，由软件的各个部分和这些部分的依赖关系构成
  * 架构决定了应用程序的质量和能力
  * 架构的目标是可扩展性、可靠性和安全性
  * 微服务为应用程序提供更高的可维护性、可测试性和可部署性
* 微服务架构是一种架构风格
  * 实现视图由多个组件构成
  * 组件是服务
  * 连接器是服务能够协作的通信协议
  * 每个服务有自己的逻辑视图架构
* 服务
  * 单一的、可独立部署的软件组件，实现了一些有用功能
  * API封装了内部实现，无法绕过API之间访问服务内部数据，强制实现了应用程序的模块化
* 松耦合
  * 服务之间使用API通信
* 共享类库的角色
  * 将一些通用的功能打包到库或模块中，减少重复
  * 更好的办法是把这些功能打包成服务
* 服务的大小并不重要
  * 更好的设计目标是能够由小团队维护，交付时间最短，与其他团队协作最少
* 为应用程序定义微服务架构
  * 第一步：将应用程序的需求提炼为各种关键请求， 用抽象的系统操作描述这些请求
  * 第二步：确定如何分解服务
    * 定义与业务能力想对应的服务
    * 围绕领域驱动设计的子域来分解和设计服务
  * 第三步：确定每个服务的API
* 识别系统操作
  * 创建由关键类组成的抽象领域模型，提供描述系统操作的词汇表
  * 确定系统操作，根据领域模型描述每个系统操作的行为
    * 命令型：创建、更新或删除数据的系统操作
    * 查询型：查询和读取数据的系统操作
* 根据业务能力进行服务拆分
  * 业务能力定义了一个组织的工作
    * 业务做什么，通常是稳定的
    * 怎么实现，随着时间变化
  * 识别业务能力
    * 通过对组织的目标、结构和商业流程的分析得来
    * 业务能力通常具有多个子能力
  * 从业务能力到服务
    * 确定了业务能力后，为每个能力或相关能力组定义服务
* 根据子域进行服务拆分
  * 子域
  * 界限上下文
* 拆分的指导规则
  * 单一职责原则
  * 闭包原则（CCP）
    * 在包中包含的所有类应该是对同类的变化的一个集合，如果对包做成修改，需要调整的类都应该在这个包之内
    * 必须耦合的类放在同一个包内
    * 根据同样原因发生变化的服务放在一个组件内
* 拆分单体应用为服务的难点
  * 网络延时
    * 对服务的分解会造成大量的往返调用
    * 将多个相关服务组合到一起，用编程语言的函数调用替换昂贵的进程间通信
  * 同步进程间导致可用性降低
  * 在服务间维持数据一致性
  * 获取一致的数据视图
  * 上帝类阻碍了拆分

* 定义服务API
  * 将每个系统操作映射到服务
    * 确定哪个服务是请求的初始入口点
    * 处理每个系统操作时，服务间如何交互
  * 确定支持服务协作所需要的API