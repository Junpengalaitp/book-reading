### 1 Kubernetes介绍
* 大型的单体应用正在被分解成小的、可独立运行的微服务，彼此之间解耦，所以它们可以被独立开部署、升级、伸缩。
* k8s使开发者可以自主部署应用，并且控制部署的频率，完全脱离运维团队的帮助。
* 同时让运维团队监控整个系统，并且在硬件故障时重新调度应用。
* 抽象了数据中心的硬件基础设施，使得对外暴露的只是一个巨大的资源池。部署和运行组件时，不用关心底层的服务器。
* 为应用程序提供一个一致的环境。
* 迈向持续交付：DevOps和NoOps
* Kubernetes的核心功能
  * 整个系统由一个主节点和若干工作节点组成，集群的规模不会造成差异性
  * 帮助开发者聚焦核心应用功能
  * 帮助运维团队获取更高的资源利用率
* Kubernetes的集群架构
  * 主节点
    * 承载kubernetes控制和管理的整个集群系统的控制面板
  * 工作节点
    * 运行用户实际部署的应用
  * 控制面板
    * 控制集群并使它们工作
      * Kubernetes API服务器：你和其他控制面板组件都要和它通信
      * Scheduler: 调度的你的应用
      * Controller Manager: 执行集群级别的功能
      * etcd: 一个可靠的分布式数据存储，它能持久化存储集群配置
  * 工作节点
    * 运行容器化应用的机器
      * Docker、rtk 或者其他的容器类型
      * Kubelet: 与API服务通信，并管理它所在的节点容器
      * Kubernetes Service Proxy(kube-proxy): 负责组件之间的负载均衡网络流量
* 使用Kubernetes的好处
  * 简化应用程序部署
  * 更好地利用硬件
  * 健康检查和自修复
  * 自动扩容
  * 简化应用部署

### 2 开始使用Kubernetes和Docker
* Pod
  * 一组紧密相关的容器，总是一起运行在同一个工作节点上，以及同一个Linux命名空间中。相反，它使用多个共存容器的理念。
  * 每个pod像一个独立的逻辑机器，拥有自己的IP、主机名、进程等，运行一个独立的应用程序。
  * 一个pod的所有容器都运行在同一个逻辑机器上，其他pod中的容器，即使运行在同一个工作节点上、也会出现在不同的节点上。
* 幕后发生的事情
  * 运行kubectl命令时，它通过像Kubernetes API服务器发送一个REST API请求，在集群中创建一个新的ReplicationController对象。
  * 然后，ReplicationController创建了新的Pod, 调度器将其调度到一个工作节点上。
  * Kubelet看到pod被调度到节点上，就告知Docker从镜像中心拉去指定的镜像，因为本地没有该镜像。
  * 下载镜像后，Docker创建并运行容器。
* 访问Web应用
  * 每个pod的IP地址是集群内部的，不能从外部集群访问。
  * 常规服务(ClusterIP服务)，比如pod，只能从集群内部访问。
  * LoadBalancer服务，可通过负载均衡的公共IP访问pod。
* 系统的逻辑区分
  * ReplicationController、pod和服务是如何组合到一起的
    * 通过kubectl run命令，没有直接创建出任何pod，而是创建了一个ReplicationController, 用于创建pod实例。
    * 为了使该pod能从集群外部访问，需要让Kubernetes将该ReplicationController管理的所有pod由一个服务对外暴露。
  * Pod和它的容器
    * 只包含一个容器，但是通常一个pod可以包含任意数量的容器。
  * ReplicationController
    * 确保始终存在一个运行中的pod实例。
    * 通常，ReplicationController用于复制pod(即创建pod的多个副本)，并让它们保持运行。
  * 为什么需要服务
    * pod的存在是短暂的，一个pod可能随时消失，或许因为故障，或许是有人删除了pod。
    * 上述情况发生后，消失的pod会被ReplicationController替换为新的pod.
    * 当一个服务被创建时，它会得到一个静态的IP, 在服务的生命周期里这个IP不会变化。客户端通过固定IP地址连接到服务，而不是直接连接pod。
    * 服务会确保其中一个pod接收连接，而不关心pod当前运行在哪里，以及它的IP地址是什么。
  * 水平伸缩应用
    * 设置期望的数量让k8s自己决定要采取哪些操作
    * 请求会随机切换到不同的pod
  * 查看应用运行在哪个节点上
    * kubectl get pods -o wide

### 3 pod：运行于k8s中的容器
  * 为何需要pod
    * 多个容器比单容器多进程好
  * 了解pod
    * 由于不能将多个进程聚集在单独容器中，我们需要另一种更高级的结构来将容器绑定到一起，并将它们作为一个单元进行管理，这就是pod的根本原理
    * 同一pod中容器之间的部分隔离
      * 容器之间是彼此完全隔离的，但我们期望的是隔离容器组，而不是单个容器，并让每个容器组内的容器共享一些资源。
      * k8s通过配置docker来让一个pod内的所有容器共享相同的Linux命名空间。
      * pod中的所有容器共享相同的主机名和网络接口。
      * 这些容器也都在相同的IPC命名空间下运行，能够通过IPC进行通信。
      * 共享相同的PID命名空间，默认不激活
      * 涉及到文件系统时，每个容器的文件系统与其他容器完全隔离。
    * 介绍平坦pod间网络
      * k8s集群中所有的pod都在同一个共享网络地址空间中，这意味着pod之间可以通过其它pod的IP地址来互相访问
    * 通过pod合理管理容器
      * 将多层应用分散到多个pod中
      * 基于扩缩考虑分割到多个pod中
  * 以YAML或者JSON描述文件创建pod
    * metadata: 名称、命名空间、标签和关于该容器的其它信息
    * spec: 包含pod内容的实际说明，例如pod的容器、volume和其它数据
    * status: 包含运行中的pod当前信息，例如pod所处的条件、每个容器的描述和状态，以及内部IP和其它基本信息
  * 使用标签组织pod
    * 介绍标签
      * 可以组织pod和其它kubernetes资源。
      * 标签是可以附加到资源的任意键值对，用于选择具有该确切标签的资源
      * 创建pod时指定标签：在metadata下面labels使用key: value表示
      * kubectl get pods --show-labels
    * 通过标签选择器列出pod子集
      * 包含（或不包含）使用特定键的标签
      * 包含特定键值的标签
      * 包含特定键的标签，但其值与我们指定的不同
  * 使用标签和选择器来约束pod调度
    * 使用场景：工作节点的硬件设施不同，需要把某些需求特定硬件的app部署到对应节点
    * 使用标签来分类工作节点
      * kubectl label node node-1 gpu=true
    * 将pod调度到特定节点
      * spec.nodeSelector.gpu: "true"
    * 调度到一个特定节点
      * 通过主机名label
      * 如果该主机不可用，将造成pod不可调度
      * 所以应该使用标签选择器来调度
  * 注解pod
    * 和标签一样，也是键值对
    * 不能用注解来分组
    * 注解可以容纳更多信息，主要用于工具使用
  * 使用命名空间对资源进行分组
    * 将对象分割成完全独立且不重叠的组
    * 了解对命名空间的需求
      * 可以将包含大量组件的复杂系统拆分为更小的不同组
      * 命名空间之间是否提供网络隔离取决于kubernetes所使用的网络解决方案
  * 停止和移除pod
    * 在删除pod的过程中，实际上我们在指示k8s终止该pod中的所有容器，k8s向进程发送一个SIGTERM信号并等待一定秒数（默认30s），使其正常关闭。如果没有及时关闭，则通过SIGKILL终止该进程。
    * 通过标签选择器删除pod
    * 通过删除整个命名空间来删除pod
    * 删除所有pod，保留ns
      * kubectl delete po --all
    * 删除命名空间中的所有资源
      * kubectl delete all --all