### 第一章 重构 第一个案例
* 重构第一步，为即将修改的代码建立一组可靠的测试环境
* 把长函数切开，并把小块的代码移至合适的类
* 任何一个傻瓜都能写出计算机可以理解的代码。唯有写出人类容易理解的代码，才是优秀的程序员

### 第二章 重构原则
* 何为重构
  * 名词：对软件内部结构的一种调整，目的是不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。
  * 动词：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。
* 为何重构
  * 改进软件设计
  * 使软件更容易理解
  * 帮助找到BUG
  * 提高编程速度
* 何时重构
  * 三次法则
  * 添加功能时重构
  * 修补错误时重构
  * 复审代码时重构

### 第三章 代码的坏味道
  * 重复代码
  * 过长函数
  * 过大的类
  * 过长参数列
  * 发散式变化
    * 经常因为不同原因在不同方向上发生变化
  * Shotgun Surgery(霰弹式修改)
    * 每次遇到变化，都必须在许多不同类做出许多小修改
  * Feature Envy(依恋情结)
  * Data Clumps(数据泥团)
  * Primitive Obsession(基本类型偏执)
  * Switch Statements
  * Parallel Inheritance Hierarchies(平行继承体系)
    * 当为一个类添加子类时，必须也为另一个类相应增加子类
  * Lazy Class(冗赘类)
  * Speculative Generality(夸夸其谈未来性)
  * Temporary Field(令人迷惑的暂时字段)
  * Message Chains(过度耦合的消息链)
  * Middle Man(中间人)
  * Inappropriate Intimacy
  * Alternative Class with Different Interfaces(异曲同工的类)
  * Incomplete Library Class(不完美的库类)
  * Data Class
  * Refused Bequest
    * 子类应该继承超类的函数和数据，当他们不需要继承，需要为这个子类新建一个兄弟类
  * 过多的注释

### 第四章 构筑测试体系
* 频繁地运行测试。每次编译请把测试类也考虑进去，每天至少执行每个测试一次。
* 编写未臻完善的测试并实际运行，好过对完美测试的无尽等待。
* 考虑可能出错的边界条件，把测试火力集中。
* 当事情被认为应该会出错时，别忘了检查是否抛出了预期的异常。
* 不要因为测试无法捕捉所有bug就不写测试，因为测试的确可以捕捉到大多数Bug.\

### 第五章 重构列表
* 重构的记录格式
  * 名称(name)
  * 概要(summary)
  * 动机(motivation)
  * 做法(mechanics)
  * 范例(examples)
* 寻找引用点
* 这些重构手法有多成熟