### 第一章 面试流程
  * 面试评价维度
    * 分析能力
      * 解决问题时是否需要很多帮助？
      * 对解决方案优化到了什么程度？
      * 用了多长时间？
      * 决策与取舍
    * 编程能力
      * 是否能将算法转化为合理的代码？
      * 代码是否整洁且结构清晰？
      * 你是否思考过潜在的错误？
      * 是否有良好的编程风格？
    * 技术知识、计算机科学基础知识
    * 经验
    * 文化契合度
* 错过了优秀人才是可以的
* 解决问题的技能很宝贵
* 基础数据结构和算法知识很有用
* 白板让你专注重要的事情


  ### 第七章 技术面试题
  * 准备事项
    * 尽量独立解题
    * 在纸上写代码
    * 在纸上写测试代码
    * 将代码照原样输入计算机
  * 必备的基础知识
    * 核心数据结构和算法
      * 数据结构
        * 链表
        * 树、单词查找树、图
        * 栈和队列
        * 堆
        * 向量/数组
        * 散列表
      * 算法
        * DFS
        * BFS
        * 二分查找
        * 并归排序
        * 快速排序
      * 概念
        * 位操作
        * 内存（堆和栈）
        * 递归
        * 动态规划
        * Big O
* 解题步骤
  * 听
    * 仔细聆听问题描述。每一个细节都可能在优化时派上用场
  * 举例 
    * edge cases
    * 例子能覆盖所有情况吗
  * 蛮力法
    * 尽快想出一个暴力解法，在此之前不要试图开发一个高效算法。
    * 给出一个朴素的算法和运行时间，然后在此基础上优化该算法。
    * 先不要写代码
  * 优化
    * 用BUD法优化朴素算法
    * 寻找未利用的信息
    * 手动解决一个例题，然后逆向思考。你是怎么解决的？
    * 给出不正确的解法，思考为什么失败。你能修复这些问题吗？
    * 权衡时间与空间。散列表至关重要
  * 梳理
    * 有了一个最优算法后，详细地回顾一遍你的算法，以确保写代码之前理顺每个细节
  * 实现
    * 目标是写出一手漂亮的代码。从一开始就追求模块化，并且通过重构清理掉不漂亮的代码
    * 持续交流，面试官乐于了解你是如何解决问题的
  * 测试
    * 概念测试，想代码复查一样，仔细审查一遍代码
    * 异常或不标准的代码
    * 热点代码，比如计算节点和空节点
    * 小测试用例，比大的快且同样有效
    * 特殊或边缘情况
    * 发现错误时，请小心修复

### 第十章 题目解法
* 树
  * 最小高度树。给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一个高度最小的二叉搜索树。
    * 让左右子树的节点个数接近
    * 让数组的中位数成为根节点
    * 以递归的方式继续执行上述步骤
  * 特定深度节点链表。给定一颗二叉树，设计一个算法，创建含有某一深度上所有节点的链表。
    * BFS层次遍历
    * DFS（preorder, inorder, postorder），记录层数，每次递归加一
  * 检查平衡性。实现一个函数，检查二叉树是否平衡（任意一个节点，其两棵子树的高度差不超过1）。
  * 合法二叉搜索树。实现一个函数，检查一颗二叉树是否为二叉搜索树。
    * 中序遍历，然后检查是否有序
    * 递归，递归左子树时，传递当前node值作为最大值，递归右子树时，传递当前弄的值作为最小值。
  * 后继者。找出BST中指定节点的下一个节点（中序后继）。
    * 如果当前节点有右子树，右子树的最左节点就是它的后继
    * 如果没有右子树
      * 当前节点是左子节点，它的父节点是后继
      * 当前节点是右子节点，它的未访问过的父节点的第一个子节点是后继
    * 如果向上访问一直没有发现左节点，说明我们在中序遍历的最末端，不会再有中序后继，返回null。

* 链表
  * 移除重复节点。移除未排序链表中的重复节点
    * 使用HashSet
    * 使用锚(O(n^2)时间复杂度)
  * 返回倒数第K个节点
    * 递归：到达尾部时返回为0的计数，每次调用加一
    * 快慢指针
  * 删除中间节点。只能访问该节点
    * 将后续节点信息复制到当前节点
  * 分割链表。以X为基准分割链表，使得所有小于X的节点排在大于或等于X的节点之前。分割元素在右半部分即可。
    * 使用两个链表，最后合并这两个链表
  * 回文链表
    * 反转并比较，只需比较前半部分。
    * 迭代法，将前半部分反转，使用栈，前半部分入栈，指针到达后半部分后，每次和栈顶元素比较
    * 递归法，每次递归将length - 2, 那么length = 0时就是链表中间。
  * 链表相交。
    * 遍历每个链表以获得链表的长度与尾节点。
    * 比较尾节点，如果不同，说明无交点。
    * 使用两个指针分别指向两个链表的头部。
    * 将较长链表的指针向前移动，移动的步数为两个链表长度的差值。
    * 同时遍历两个链表，直到两个指针指向的节点相同。
  * 环路检测
    * 快慢指针，slow每次一步，fast每次两步
    * 两者相遇时，将slow指向头节点，然后两个指针同时前进，每次一步
    * 返回新的相遇点

* 数组
  * 旋转矩阵。将矩阵顺时针旋转90度
    * 逐层旋转，使用O(n^2)时间，O(1)空间
    * Transpose, then reverse each row

* 字符串
  * 判断字符串是否唯一。确定字符串里没有重复的字符。
    * 是不是ASCII码？如果是，最多只有128个字符，超过了这个字符可立即返回false。
    * 使用一个HashTable, 或者数组（ASCII码的情况下）。
    * 使用bitwise，不占用额外空间。

* 判定是否为字符重排。给定两个字符串，确定其中一个经过重拍后，能否变成另一个字符串。
  * 排序字符串
  * 使用hashmap进行计数

* URL化。将字符串中的空格全部替换成%20。

* 回文排列。判断一个字符串是否是某个回文字符串的排列之一。
  * 偶数长度的字符串所有字符必须出现偶数次
  * 奇数长度的字符串必须刚好有一个字符出现奇数次
  * 一个回文排列不可能超过一个出现奇数次的字符。

* 一次编辑。判断一个字符串只需要做出插入、删除、替换操作中的一个可以转换为另一个字符串。
  * 替换：两个字符串仅在一个位置上不同
    * 同时遍历两个字符串，第二次遇到不同的字符时，返回false
  * 插入：除了在字符串某一位置需要整体移动一次外，它们是完全相同的。
  * 删除：同插入，只是插入的相反操作
    * 同时遍历两个字符串，当第一次遇到不同时，将较长的字符串idx + 1，第二次遇到不同时，如果两个idx不同，返回false。
  