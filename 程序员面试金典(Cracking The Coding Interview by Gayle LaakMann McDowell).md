### 第一章 面试流程
  * 面试评价维度
    * 分析能力
      * 解决问题时是否需要很多帮助？
      * 对解决方案优化到了什么程度？
      * 用了多长时间？
      * 决策与取舍
    * 编程能力
      * 是否能将算法转化为合理的代码？
      * 代码是否整洁且结构清晰？
      * 你是否思考过潜在的错误？
      * 是否有良好的编程风格？
    * 技术知识、计算机科学基础知识
    * 经验
    * 文化契合度
* 错过了优秀人才是可以的
* 解决问题的技能很宝贵
* 基础数据结构和算法知识很有用
* 白板让你专注重要的事情


  ### 第七章 技术面试题
  * 准备事项
    * 尽量独立解题
    * 在纸上写代码
    * 在纸上写测试代码
    * 将代码照原样输入计算机
  * 必备的基础知识
    * 核心数据结构和算法
      * 数据结构
        * 链表
        * 树、单词查找树、图
        * 栈和队列
        * 堆
        * 向量/数组
        * 散列表
      * 算法
        * DFS
        * BFS
        * 二分查找
        * 并归排序
        * 快速排序
      * 概念
        * 位操作
        * 内存（堆和栈）
        * 递归
        * 动态规划
        * Big O
* 解题步骤
  * 听
    * 仔细聆听问题描述。每一个细节都可能在优化时派上用场
  * 举例 
    * edge cases
    * 例子能覆盖所有情况吗
  * 蛮力法
    * 尽快想出一个暴力解法，在此之前不要试图开发一个高效算法。
    * 给出一个朴素的算法和运行时间，然后在此基础上优化该算法。
    * 先不要写代码
  * 优化
    * 用BUD法优化朴素算法
    * 寻找未利用的信息
    * 手动解决一个例题，然后逆向思考。你是怎么解决的？
    * 给出不正确的解法，思考为什么失败。你能修复这些问题吗？
    * 权衡时间与空间。散列表至关重要
  * 梳理
    * 有了一个最优算法后，详细地回顾一遍你的算法，以确保写代码之前理顺每个细节
  * 实现
    * 目标是写出一手漂亮的代码。从一开始就追求模块化，并且通过重构清理掉不漂亮的代码
    * 持续交流，面试官乐于了解你是如何解决问题的
  * 测试
    * 概念测试，想代码复查一样，仔细审查一遍代码
    * 异常或不标准的代码
    * 热点代码，比如计算节点和空节点
    * 小测试用例，比大的快且同样有效
    * 特殊或边缘情况
    * 发现错误时，请小心修复

### 第十章 题目解法
* 树
  * 最小高度树。给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一个高度最小的二叉搜索树。
    * 让左右子树的节点个数接近
    * 让数组的中位数成为根节点
    * 以递归的方式继续执行上述步骤
  * 特定深度节点链表。给定一颗二叉树，设计一个算法，创建含有某一深度上所有节点的链表。
    * BFS层次遍历
    * DFS（preorder, inorder, postorder），记录层数，每次递归加一
  * 检查平衡性。实现一个函数，检查二叉树是否平衡（任意一个节点，其两棵子树的高度差不超过1）。
  * 合法二叉搜索树。实现一个函数，检查一颗二叉树是否为二叉搜索树。
    * 中序遍历，然后检查是否有序
    * 递归，递归左子树时，传递当前node值作为最大值，递归右子树时，传递当前弄的值作为最小值。
  * 后继者。找出BST中指定节点的下一个节点（中序后继）。
    * 如果当前节点有右子树，右子树的最左节点就是它的后继
    * 如果没有右子树
      * 当前节点是左子节点，它的父节点是后继
      * 当前节点是右子节点，它的未访问过的父节点的第一个子节点是后继
    * 如果向上访问一直没有发现左节点，说明我们在中序遍历的最末端，不会再有中序后继，返回null。

* 链表
  * 移除重复节点。移除未排序链表中的重复节点
    * 使用HashSet
    * 使用锚(O(n^2)时间复杂度)
  * 返回倒数第K个节点
    * 递归：到达尾部时返回为0的计数，每次调用加一