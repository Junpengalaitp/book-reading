# 第一章 数据模型设计
* 想要轻松写出高效的SQL, 要有优秀的数据库设计。如果数据库设计违反了本章中的原则，应当找到问题并修复。
* 如果数据库不在你的控制之下，至少你要能够理解你面对的问题是什么，然后再把你认为可行的方案解释给有设计权力的人。
* 即使你没办法改变设计，在SQL中也有其他的变通方案可以解决某些问题。

## 第1条：确保所有表都有主键

## 第2条：避免存储冗余数据

## 第3条：消除重复数据组

## 第4条：每行只存储一个属性

## 第5条：理解为什么存储计算列通常有害无益
* 在数仓中可行，ods中会带来性能问题

## 第6条：定义外键以确保引用完整性

## 第7条：确保表间关系的合理性

## 第8条：当第三范式不够时，采用更多范式

## 第9条：非规范化数据仓库

# 第二章 可编程性与索引设计

## 第10条：创建索引时空值的影响

## 第11条：创建索引是谨慎考虑以最小化索引和数据扫描

## 第12条：索引不只是过滤

## 第13条：不要过度使用触发器

## 第14条：使用过滤索引包含或排除数据子集

## 第15条：使用声明式约束替代编码校验

## 第16条：了解数据库使用的SQL方言并编写相应的代码

## 第17条：了解何时在索引中使用计算结果

# 第3章 当你不能改变设计时

## 第18条：使用视图（view）来简化不能更改的内容

## 第19条：使用ETL将非关系数据库转化为有用的信息

## 第20条：创建汇总表并维护

## 第21条：使用UNION语句将非规范化数据列转行
* SELECT Category, 'OCT' AS sales_month, OctQuantity AS Quantity, OctSales AS SalesAmt
  FROM SalesSummary
  UNION 
  SELECT Category, 'Nov', NovQuantity, NovSales
  FROM SalesSummary
  UNION 
  SELECT Category, 'Dec', DecQuantity, DecSales
  FROM SalesSummary

# 第4章 过滤与查找数据

## 第22条：了解关系代数及其如何在SQL中实现
* 选择：选择行
* 投影：选择列
* 连接
* 交集
* 笛卡尔积：cross join
* 并集
* 除
* 差集：EXCEPT

## 第23条：查找不匹配或缺失的记录
* NOT IN 
* NOT EXISTS
* LEFT JOIN

## 第24条：了解何时使用CASE解决问题
* 在任何需要将表达式作为SELECT子句的返回列，或作为WHERE和HAVING子句的搜索条件时


## 第25条：了解解决多条件查询的技术
* 使用函数正确地解决复合条件

## 第26条：如需完美匹配，先对数据进行除操作
* 查找符合给定工作所有要求的所有应职者
* 列出可以提供构造组件零件的所有供应商
* 显示订购某一套产品的所有客户

## 第27条：如何按时间范围正确地过滤日期和时间的列
* 使用DATEADD()函数
* 不要依赖隐式日期转化，使用显式转化函数来处理日期字符
* 不要将函数应用于日期和时间列，否则查询将不能使用索引
* 使用>=和\<代替BETWEEN


## 第28条：书写可参数化搜索的查询以确保引擎使用索引

## 第29条：正确地定义左连接的右侧
* 在SQL中使用OUTER JOIN执行差集操作
* 当你对外部WHERE子句中的左连接加入右侧数据使用过滤时，你将无法获得所需要的结果
* 要正确地过滤数据子集，必须在数据库系统执行外连接之前使用过滤

# 第5章：聚合

## 第30条：理解GROUP BY的工作原理
* FROM子句生成数据集
* WHERE子句过滤有FROM子句生成的数据集
* GROUP BY子句聚合由WHERE子句过滤的数据集
* HAVING子句转换过滤的聚合数据集
* SELECT子句转换过滤的聚合数据集
* ORDER BY子句对变换后的数据集进行排序

## 第31条：简化GROUP BY子句
* 对于同时需要聚合和详细信息的查询，首先在子查询中执行所有聚合，然后将结果再连接到其他表以查询详细信息

## 第32条：利用GROUP BY或HAVING解决复杂问题
* HAVING能够将一个组的总体结果与另一个聚合结果进行比较

## 第33条：避免使用GROUP BY解决寻找MAX,MIN
* 使用LEFT JOIN主表联接到自身
* 将GROUP BY子句中的每一列都变成ON子句的一部分，并使用=进行比较
* MAX()或MIN()子句中的列将变成ON子句的一部分，并且使用小于或大于
* 应该为ON子句的列添加索引，以获得更好的性能

## 第34条：使用OUTER JOIN时避免获取错误的COUNT()
* JOIN时COUNT(*)会包括NULL的记录
* 可以使用子查询来统计

## 第35条：测试HAVING COUNT(x) < 某数时包含零值记录
* 使用INNER JOIN不能找出零计数
* 过滤左连接的右侧，将获得相当于内连接的结果。将过滤器移入子查询或在ON条件中过滤右侧
* 当想找出大于1的总计数时，寻找0计数也帮助你识别数据中的问题

## 第36条：使用DISTINCT获取不重复的计数
* COUNT(*)返回一组项目的总数，包括空值和重复项
* COUNT(ALL + 表达式)对一组数据中的每一条记录求表达式的值，并返回非空值的数量
* COUNT(DISTINCT + 表达式)对一组数据中的每一条记录求表示的值，并返回唯一的非空值

## 第37条：知道如何使用窗口函数
* 从OVER子句开始，表示在SUM()表达式上使用一个窗口
* PARTITION BY: 指定如何划分窗口，如果省略它，你的数据库系统将在整个结果集上应用该函数
* PATITION仅仅将分组应用于SUM()创建的窗口，并且是独立的，而GROUP BY将在整个查询中应用分组，并不允许和聚合的列应用
* ORDER BY: 结果对返回行的顺序敏感

## 第38条：创建行号与排名
* 必须始终对ROW_NUMBER()、RANK()和其他排序函数进行窗口化，因此必须与相应的OVER子句一起出现
* 考虑如何使用排序函数处理关联。如果你需要连续排名，应该使用DENSE_RANK()
* ORDER BY谓词对于这类函数是强制性的，因为它会影响结果如何排序

## 第39条：创建可移动聚合函数
* RANGE, 三个有效的边界选项
  * BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
  * BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING 
  * BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING 

* 使用RANGE时，将当前行与其他行进行比较，并根据ORDER BY谓词分组
* 可以用ROWS替代RANGE。除了以上三个，还提供了另外三个选项
  * BETWEEN N PRECEDING AND CURRENT ROW
  * BETWEEN CURRENT ROW AND N FOLLOWING
  * BETWEEN N PRECEDING AND N FOLLOWING
* 无论何时需要将窗口框架的边界更改为非默认设置，即使可选，也必须指定ORDER BY谓词
* 如果需要为窗口框架定义任意大小，则必须使用ROWS,这样可以输入需要包含在窗口框架的前后几行
* 可以选择RANGE逻辑分组行或ROWS物理偏移行。如果ORDER BY谓词不返回重复值，则两者的结果是等效的

## 第40条：了解在何处使用子查询

## 第41条：了解关联和非关联子查询的差异
* 使用非关联子查询
  * 在FROM子句中作为一个被过滤的数据集
  * 在WHERE子句IN条件中作为单列数据集，或者在WHERE或HAVING子句的对比条件中作为单个值
* 关联子查询
  * 在WHERE或HAVING子句中使用一个或多个过滤器，并依赖外部查询提供的值

## 第42条：尽可能使用公共表达式而不是子查询
* 利用CTE，你可以简化多次使用相同子查询的复杂查询
* CTE可以免除使用无意中更改的功能，而这样的修改会导致使用该函数的查询无法正常工作
* 在同一SQL中，CTE允许你直接定于要嵌入到另一个查询中的子查询，这样也更容易理解
* 虽然你可以使用递归CTE生成一些数据值，这些值可能在计数表中找到，但保存的计数表效率更高，因为你可以对其添加索引
* 你可以使用递归CTE遍历层次关系，并以有意义的方式进行展示
