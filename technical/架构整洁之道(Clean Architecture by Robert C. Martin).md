### 第一章 概述
* 目标：用最小的人力成本来满足构建和维护该系统的需求
* 乱麻系统的特点
  * 没有经过设计，匆忙被构建起来。
  * 为了加快发布速度，拼命往团队里加入新人。
  * 决策层对代码质量提升和设计结构优化存在着持续的、长久的忽视。
  * 无论投入多少个人时间，救了多少次火，加了多少次班，产出始终上不去。
  * 工程师大部分时间都消耗在对现有系统的修修补补上，而不是真正完成实际功能。
  * 这些工程师的任务是：拆了东墙补西墙，周而往复，偶尔才有精力实现一点小功能。
* 龟兔赛跑的启发
  * 慢但是稳，是成功的秘诀
  * 该比赛并不是拼谁跑的快，也不是拼谁更有力气
  * 心态越急，反而跑的越慢
* 持续低估好的、良好设计的、整洁代码的重要性
* 持续欺骗自己：“我们未来可以重构代码，产品上线最重要”
* 工程师忙于新功能，没有时间重构老的代码。循环往复，系统成了一团乱麻，生产效率持续直线下降，直至为零
* 胡乱编写代码的工作速度其实比循规蹈矩更慢

### 第二章 两个价值的维度
* 行为价值
  * 按照需求让软件运转，给系统的使用者创造价值
* 架构价值
  * 可以用灵活的方式进行修改
* 系统行为：紧急，但是并不总是特别重要
* 系统架构：重要，但不总是特别紧急
* 为好的软件架构而持续斗争

### 第三章 编程范式总览
* 结构化编程
  * 对程序控制权的直接转移进行了限制和规范
* 面向对象编程
  * 面向对象编程对程序控制权的间接转移进行了限制和规范
* 函数式编程
  * 函数式编程对程序中的赋值进行了限制和规范
  
### 第四章 结构化编程
* 可推导性
* goto有害
* 功能性降解拆分
* 形式化证明没有发生
* 科学来救场
* 测试

### 第五章 面向对象编程
* 封装
* 继承
* 多态

### 第六章 函数式编程
* 不可变性
* 可变性的隔离
* 事件溯源

### 第七章 SRP: 单一职责原则
* 任何软件模块都应该只对某一类行为者负责

### 第八章 OCP: 开闭原则
* 设计良好的软件应该易于扩展，抗拒修改
* 不需要修改的情况下轻易扩展

### 第九章 LSP里氏替换原则
* 如果对于每个类型是S的对象o1都存在一个类型为T的对象o2, 能使能操作T类型的程序P在用o2替换o1时行为保持不变，我们就可以将S称为T的子类型。
* 从指导如何使用继承到更广泛的，指导接口与其实现方式的设计原则
  
### 第十章 ISP接口隔离原则
* 任何层次的软件设计如果依赖于不需要的东西，都会是有害的。

### 第十一章 依赖反转原则
* 多引用抽象类型，而非具体实现，使用抽象工厂
* 争取在不修改接口的情况下为软件增加新的功能
* 不要在具体实现上创建衍生类
* 不要override包含具体实现的参数
* 避免在代码中写入于任何具体实现相关的名字，或者是其他容易变动的事物的名字

### 第十二章 组件
  
### 第十三章 组件聚合
* RCP: 复用/发布等同原则
  * 软件复用的最小粒度应等同于其发布的最小粒度。
* CCP: 共同闭包原则
  * 我们应该将那些会同时修改，并且为相同目的而修改的类放到同一个组件中，而将不会同时修改，并且不会为了相同目的而修改的那些类放到不同的组件中。
* CRP: 共同复用原则
  * 不要强迫一个组件的用户依赖他们不需要的东西

### 第十四章 组件耦合
* 无依赖环原则
* 自上而下的设计
* 稳定依赖原则
* 稳定抽象原则

### 第十五章 什么是软件架构
* 架构师应该是能力最强的程序员，在自身承接编程任务的同时，逐渐引导整个团队向一个能够最大化生产力的系统设计方向前进。
* 架构的质量是由它的构建者所决定的，软件架构这项工作的实质就是规划如何将系统切分成组件，并安排好组件之间的排列关系，以及组件之间相互通信的方式。
* 架构的目的就是为了在工作中更好地对这些组件进行研发、部署、运行和维护。
* 如果想设计一个便于推荐的各项工作的系统，其策略就是要在设计中尽可能长时间地保留尽可能多的选项。
* 软件架构设计的主要目的是支撑软件系统的全生命周期，设计良好的架构可以让系统便于理解、易于修改、方便维护，并且能轻松部署。架构的终极目标就是最大化程序员生产力，同时最小化系统的总运营成本。
* 开发
  * 系统架构的作用就是要方便其开发团队对它的开发
* 部署
  * 实现一键部署应该是软件架构的一个目标
* 运行
  * 架构应该能明确反映该系统在运行时的需求
* 维护
  * 降低维护风险，减少理解成本
* 保持可选项

### 第十六章 独立性
* 用例
  * 一个系统的架构必须能支持其自身的设计意图
* 运行
  * 架构应该支持将其计算部分拆分成一系列小型服务，然后让它们并行运行在不同服务器上。
* 开发
  * 协作开发的系统必须具有相应的软件架构，这样才可以独立完成各自的工作，不会互相干扰
* 部署
  * 良好的软件架构可以让系统在构建完成后立刻能部署
* 保留可选项
  * 系统在任何情况下都能方便的做出必要的变更
* 按层解耦
  * UI，独有业务逻辑，领域普适的业务逻辑，数据库等
* 用例的解耦
  * 按照变更原因的不同对系统进行解耦，可以持续地向系统內添加新的用例，而不会影响旧的用例。
* 解耦的模式
  * 为了在不同的服务器上运行，被隔离的组件不能依赖于某个处理器上的同一个地址空间，它们必须是独立的服务，然后通过某种网络来进行通信
* 开发的独立性
  * 架构的设计目标应该包括支持系统的开发
* 部署的独立性
* 解耦模式
  * 源码层次：控制源码模块之间的依赖关系，实现一个模块的变更不会导致其他模块变更或重编译
  * 部署层次：控制部署单元间的依赖关系，实现一个模块的变更不影响其他模块重新构建或部署
  * 服务层次：将组件间的依赖关系降低到数据结构级别，然后仅通过网络数据包来通信。

### 第十七章 划分边界
* 边界的作用是将软件分割成各种元素，以便约束边界两侧之间的依赖关系。
* GUI与业务逻辑无关，数据库与GUI无关，数据库与业务逻辑无关，它们彼此之间应该有一条边界线
* 插件式架构
  * 系统的核心业务逻辑必须和其他组件隔离，保持独立。
  * 这些其他组件要么可以去掉，要么是有多种实现。
  * SRP的具体体现

### 第十八章 边界分析
* 跨边界调用
  * 需要对依赖关系进行合理管控
* 单体结构
  * 常见的架构边界通常没有一个固定的物理形式，它们只是对同一个进程，同一个地址空间内的函数和数据进行了某种划分。
* 部署层次的组件
* 线程
* 本地进程
* 服务

### 第十九章 策略与层次
* 层次
  * 一条策略离系统的输入输出越远，它所属的层次就越高

### 第二十章 业务逻辑
* 业务实体
  * 包含了一系列用于操作关键数据的业务逻辑的对象
* 用例
* 请求和相应模型

### 第二十一章 尖叫的软件架构
* 架构设计的主题
  * 软件的系统架构应该为该系统的用例提供支持
* 架构设计的核心目标
  * 良好的架构设计应该尽可能地允许用户推迟和延后决定采用什么框架、工具以及使用环境的情况下完整地描述用例

### 第二十二章 整洁架构
* 独立于框架
* 可被测试
* 独立于UI
* 独立于数据库
* 独立于任何外部机构