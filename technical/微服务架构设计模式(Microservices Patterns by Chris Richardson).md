### 第一章 逃离单体地狱
* 迈向单体地狱的漫长旅程
  * 早期单体架构的好处
    * 应用开发很简单
    * 易于大规模修改
    * 测试相对简单直观
    * 部署简单明了
    * 横向扩展容易
  * 单体地狱
    * 过度的复杂性吓退开发者
    * 开发速度缓慢
    * 开发到部署周期长，容易出问题
    * 难以扩展
    * 交付可靠难以达成
    * 长期依赖过时的技术栈
* 微服务
  * 好处
    * 使大型的复杂应用程序可以持续交付部署
    * 每个服务都相对较小并容易维护
    * 服务可以独立部署和扩展
    * 实现团队自治
    * 容易实验和采纳新技术
    * 更好的容错性
  * 弊端
    * 服务的拆分和定义是一项挑战
    * 分布式带来的复杂性
    * 部署跨越多个服务的功能需要谨慎
    * 开发者需要思考在什么阶段使用微服务架构

### 第二章 服务的拆分策略
* 微服务架构到底是什么
  * 软件架构：一种抽象结构，由软件的各个部分和这些部分的依赖关系构成
  * 架构决定了应用程序的质量和能力
  * 架构的目标是可扩展性、可靠性和安全性
  * 微服务为应用程序提供更高的可维护性、可测试性和可部署性
* 微服务架构是一种架构风格
  * 实现视图由多个组件构成
  * 组件是服务
  * 连接器是服务能够协作的通信协议
  * 每个服务有自己的逻辑视图架构
* 服务
  * 单一的、可独立部署的软件组件，实现了一些有用功能
  * API封装了内部实现，无法绕过API之间访问服务内部数据，强制实现了应用程序的模块化
* 松耦合
  * 服务之间使用API通信
* 共享类库的角色
  * 将一些通用的功能打包到库或模块中，减少重复
  * 更好的办法是把这些功能打包成服务
* 服务的大小并不重要
  * 更好的设计目标是能够由小团队维护，交付时间最短，与其他团队协作最少
* 为应用程序定义微服务架构
  * 第一步：将应用程序的需求提炼为各种关键请求， 用抽象的系统操作描述这些请求
  * 第二步：确定如何分解服务
    * 定义与业务能力想对应的服务
    * 围绕领域驱动设计的子域来分解和设计服务
  * 第三步：确定每个服务的API
* 识别系统操作
  * 创建由关键类组成的抽象领域模型，提供描述系统操作的词汇表
  * 确定系统操作，根据领域模型描述每个系统操作的行为
    * 命令型：创建、更新或删除数据的系统操作
    * 查询型：查询和读取数据的系统操作
* 根据业务能力进行服务拆分
  * 业务能力定义了一个组织的工作
    * 业务做什么，通常是稳定的
    * 怎么实现，随着时间变化
  * 识别业务能力
    * 通过对组织的目标、结构和商业流程的分析得来
    * 业务能力通常具有多个子能力
  * 从业务能力到服务
    * 确定了业务能力后，为每个能力或相关能力组定义服务
* 根据子域进行服务拆分
  * 子域
  * 界限上下文
* 拆分的指导规则
  * 单一职责原则
  * 闭包原则（CCP）
    * 在包中包含的所有类应该是对同类的变化的一个集合，如果对包做成修改，需要调整的类都应该在这个包之内
    * 必须耦合的类放在同一个包内
    * 根据同样原因发生变化的服务放在一个组件内
* 拆分单体应用为服务的难点
  * 网络延时
    * 对服务的分解会造成大量的往返调用
    * 将多个相关服务组合到一起，用编程语言的函数调用替换昂贵的进程间通信
  * 同步进程间导致可用性降低
  * 在服务间维持数据一致性
  * 获取一致的数据视图
  * 上帝类阻碍了拆分

* 定义服务API
  * 将每个系统操作映射到服务
    * 确定哪个服务是请求的初始入口点
    * 处理每个系统操作时，服务间如何交互
  * 确定支持服务协作所需要的API

### 第三章 微服务架构中的进程间通信
* 概述
  * 交互方式
    * 一对一
      * 请求/响应：可能会造成阻塞，紧耦合
      * 异步请求/响应：不阻塞，不会马上返回
      * 单向通知：不需要响应
    * 一对多
      * 发布/订阅
      * 发布/异步响应：发布请求后，等待感兴趣的服务返回响应
  * 定义API
    * 服务和客户端在微服务中不一定一起编译部署，可能导致运行时的故障
  * API的演化
    * 微服务架构中改变API并不容易，因为客户端可能由别的团队，甚至别的公司开发。
    * 语义化版本控制
  * 消息的格式
    * 文本：JSON，XML
    * 二进制：Protocol Buffers, Avro
* 基于同步远程过程调用模式的通信
  * REST
* 基于异步消息模式的通信
  * 消息代理

### 第四章 使用Saga管理事务
* 微服务下架构下的事务管理
  * 需求
    * 因为每一个服务都有自己的私有数据库，需要一种机制来保障多数据库环境下的数据一致性
  * 挑战
    * 分布式事务
  * 使用Saga
    * 由一连串的本地事务组成
    * 使用补偿事务来回滚做出的改变

### 第五章 微服务架构中的业务逻辑设计
* 业务逻辑组织模式
  * 面向过程的事务脚本模式
    * 实现行为的类和储存数据的类是分开的
  * 面向对象的领域建模模式
    * 除非是编写一个非常简单的程序，否则应该抵制面向过程，使用领域模型模式，进行面向对象设计
    * 有的类只有行为，有的类只有状态，更多的类同时具有行为和状态
  * 关于领域驱动设计
    * 实体(entity): 具有持久化ID的对象，具有相同属性值的两个实体是不同对象。
    * 值对象(value object): 作为值的集合对象。具有相同属性值的两个值对象可以互换使用。
    * 工厂(factory): 负责实现对象创建逻辑的对象或方法，该逻辑过于复杂，无法用构造函数完成。还可以隐藏被实例化的具体类。
    * 储存库(repository): 用来访问持久化实体的对象，封装了数据库底层机制
    * 服务(service): 实现不属于实体或值对象的业务逻辑对象
* 使用聚合设计模式领域模型
  * 模糊边界带来的问题
    * 概念模糊
    * 更新业务对象时导致问题
  * 聚合拥有明确的边界
    * 聚合代表了一致的边界
    * 识别聚合是关键
  * 聚合的规则
    * 只引用聚合根
    * 聚合间引用必须使用主键
    * 在一个事务中，只能创建或更新一个聚合
  * 聚合的颗粒度
  * 使用聚合设计业务逻辑
* 发布领域事件
  * 事件(Event):
    * 发生的事情
    * 值得注意的事情
    * 活动
    * 事故
  * 为什么需要发布变更事件
    * 聚合在被创建时，或发生其他重大更改时发布领域事件
    * 使用基于编排的Saga维护服务之间的数据一致性
    * 通知维护数据副本的服务，源数据已经发生了更改。命令查询职责隔离
    * 通过Webhook或消息代理通知不同的应用程序，以触发下一步业务流程
    * 按顺序通知同一个应用程序的不同组件，例如将WebSocket消息发送到用户的浏览器
    * 向用户发送短信或电子邮件通知
    * 监控领域事件以验证应用程序是否正常运行
    * 分析领域事件，为用户模型建模
  * 什么是领域事件
    * 领域事件的每个属性都是原始值或值对象
    * 通常具有元数据
  * 事件增强
    * 事件包含接收方需要的信息
  * 识别领域事件
    * 事件触发器
      * 用户操作
      * 外部系统
      * 另一个领域事件
      * 时间的流逝
    * 生成和发布领域事件

### 第六章 使用事件溯源开发业务逻辑
* 概述
  * 将聚合以一系列事件的方式持久化保存。每个事件代表聚合的一次状态变化。应用通过重放事件来重新创建聚合的当前状态
  * 传统持久化技术的问题
    * 对象与关系的“阻抗失调”
      * 表结构和复杂对象关系不匹配
    * 缺乏聚合的历史
      * 只储存当前状态，如果需要保存历史记录，需要自己开发实现
    * 实施审计功能将非常烦琐且容易出错
    * 事件发布凌驾于业务逻辑之上
  * 什么是事件溯源
    * 以事件为中心，用于实现业务逻辑和聚合的持久化

### 第七章 在微服务架构中实现查询
* API组合模式
* 命令查询职责隔离(CQRS)模式
* API组合模式
  * 让拥有数据的服务的客户端负责调用服务，并组合服务返回的查询结果
  * 设计缺陷
    * 有谁来担任API组合器的角色
    * API组合器应该使用响应式编程模型
    * 增加了额外的开销
    * 带来可用性降低的风险
    * 缺乏事务数据一致性
* 命令查询职责隔离(CQRS)模式

### 第八章 外部API模式

