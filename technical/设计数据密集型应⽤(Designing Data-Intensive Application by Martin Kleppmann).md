# 第一部分
* 数据密集型应用设计的基本思想

## 第一章 可靠性、可扩展性、可维护性
* 数据密集型应用通常由提供通用功能的标准组件构建而成
  * 存储数据: 数据库
  * 减少昂贵操作的次数：缓存
  * 搜索、过滤数据：搜索索引
  * 跨进程通信：流处理
  * 定期处理累积的大批量数据：批处理


### 关于数据系统的思考
* 新的存储和数据处理工具不断出现，它们针对不同的场景进行优化，因此不在适合生硬地归入传统类别。
  * 缓存Redis可以作为消息队列
  * Kafka消息队列可以向数据库一样持久化消息
* 单个工具不足以满足应用程序的复杂以及严格的要求，总体工作被拆分成一系列能被单个工具高效完成的任务，通过应用代码将它们结合起来。
* 通过API提供多个工具组合后的功能，组合后的工具时一个全新的，专用的数据系统，提供特定的保证。例如缓存在写入时会作废或更新，以便外部客户端获取一致的结果。

#### 可靠性(Reliability)
* 系统在困境(adversity)(硬件、软件故障，人为错误)中仍然可以正常工作(正确完成功能，并达到期望的水准)
* 可靠软件的典型期望
  * 表现出用户所期望的功能
  * 允许用户犯错，允许用户以出乎意料的方式使用软件
  * 在预期的负载和数据量下，性能满足要求
  * 能防止未经授权的访问和滥用
* 故障(fault): 造成错误的原因
* 容错/韧性(fault-tolerant/resilient): 能预料并应对故障的系统特性
* 失效(failure): 故障为系统的部分状态偏离其标准，失效是整个系统停止服务
* 故意触发来提高故障率是有意义的，可以确保容错机制不断运行并接受考验
* 相对于阻止错误，我们应更倾向于容忍错误

#### 硬件故障
* 增加单个硬件的冗余度
#### 软件错误
* 硬件故障一般是随机的、相互独立的，大量硬件组件不太可能同时失效。
* 系统性错误(systematic error)
  * 难以预料、跨节点相关的，可能造成链式失效
  * 接受特定错误输入后导致所有应用服务器实例崩溃的BUG
  * 失控进程会占用一些共享资源
  * 系统依赖的服务变慢或没有正确的响应
  * 级联故障，一个组件中的小故障触发另一个组件中的故障，进而触发更多的故障
* 预防方法
  * 仔细考虑系统中的假设和交互
  * 彻底的测试
  * 进程隔离
  * 允许进程崩溃并重启
  * 测量、监控、并分析生成环境中的系统行为
  * 如果系统能够提供一些保证(例如在一个消息队列中，进入与发出的消息数量相等)，那么系统就可以在运行时不断自检，并在出现差异(discrepancy)时报警。
#### 人为错误
* 以最小化犯错机会的方式设计系统
* 将容易犯错的地方与可能失效的地方解耦，提供一个功能齐全的非生产环境沙箱
* 在各个层次进行彻底的测试
* 允许从人为错误中简单快速地恢复，以最大限度地减少失效情况带来的影响。例如快速回滚配置变更，分批发布新代码，并提供数据重算工具
* 配置详细和明确的监控，比如性能指标和错误率。在其他工程学科中就是遥测(telemetry)
* 良好的管理实践与充分的培训
#### 可靠性有多重要？
* 商务应用中的错误会导致生产力损失（也许数据报告不完整还有法律风险），而电商网站的终端则可能导致收入和声誉的巨大损失。

#### 可扩展性(Scalability)
* 系统现在运行正常，不代表未来也能可靠运行。服务降级(degradation)的一个常见原因是负载增加。

##### 描述负载
* 由合理的办法应对系统的增长(数据量、流量、复杂性)
* 负载参数(load parameters)
  * 每秒Web请求数量
  * 数据库读写比率
  * 同时活跃的用户数量
  * 缓存命中率
  * ...

##### 描述性能
* 增加负载参数并保持系统资源不变时，系统性能收到的影响？
* 增加负载参数并保持性能不变时，需要增加多少系统资源？
* 吞吐量(throughput): 每秒可处理的记录数量，或者在特定规模数据集上运行作业的总时间。通常用在像Hadoop这样的批处理系统上。
* 响应时间(response time): 客户端发送请求到收到响应的时间，通常用于在线系统上。包括网络和排队延时。
  * 响应时间的尾部延时非常重要，因为它直接影响用户体验
    * 响应时间最慢的客户往往是数据最多的客户，也就是最有价值的客户。
    * Amazon观察到：响应时间增加100毫秒，销售量就会减少1%
  * 百分位点通常用于服务基本目标(SLO, service level objectives)和服务级别协议(SLA, service level agreements)
    * 例如服务响应时间的中位数小于200毫秒，且99.9百分位点低于1秒，则认为服务工作正常。
  * 排队延时(queueing delay)通常占了高百分位点处响应时间的很大一部分。由于服务器只能并行处理少量的事务，所以只需少量缓慢请求就能阻塞后续请求的处理(头部阻塞 head-of-line blocking)
* 当一个请求需要多个后端请求组合完成时，单个后端慢请求就会拖慢整个终端用户的请求

##### 应对负载的方法
* 纵向扩展(scaling up)/垂直扩展(vertical scaling)
* 横向扩展(scaling out)/水平扩展(horizontal scaling)
* 弹性扩展：检测到负载时自动增加计算资源
* 一个良好适配应用的可扩展架构，是围绕这假设(assumption)建立的
  * 哪些操作是常见的？
  * 哪些操作是罕见的？


#### 可维护性(Maintainability)
* 不同的人员在不同的周期都能在系统上高效地工作
* 可操作性(Operability)：人生苦短，关爱运维
  * 运维的职责
    * 监控系统运行情况，并在服务状态不佳时快速恢复服务
    * 跟踪问题的原因
    * 及时更新软件和平台
    * 了解系统间相互作用，以便在异常造成损失前进行规避
    * 预测未来问题，并在问题出现之前加以解决(如容量规划)
    * 建立部署，配置和管理方面的良好实践，编写相应工具
    * 执行复杂的维护任务，例如将应用程序跨平台迁移
    * 当配置变更时，维持系统的安全性
    * 定义工作流程，使运维操作可预测，并保持生产环境稳定
    * 维持组织对系统的了解
  * 良好的可操作性意外着更轻松的日常工作，进而运维团队能专注于高价值的事情。数据系统可以通过各种方式使日常任务更轻松
    * 通过良好的监控，提供对系统内部状态和运行时行为的可见性(visibility)
    * 为自动化提供良好支持，将系统与标准化工具相集成
    * 避免依赖单台机器(在整个系统继续不间断运行的情况下允许机器停机维护)
    * 提供良好的文档和易于理解的操作模型
    * 提供良好的默认行为，但也允许管理员自由覆盖默认值
    * 有条件时进行自我修复，但也允许管理员手动控制系统状态
    * 行为可预测，最大限度减少意外

* 简单性(Simplicity)：管理复杂度
  * 消除额外的(accidental)复杂度: 由具体实现中出现，而非用户视角的问题本身复杂度。
  * 使用抽象，好的抽象可以将大量实现细节隐藏在一个干净，简单易懂的外观下面。也可以提升代码的复用性，提高效率。

* 可演化性(evolability)：拥抱变化
  * 系统的需求处于常态的变化中
    * 新的事实
    * 意想不到的应用场景
    * 业务优先级变化
    * 用户要求的新功能
    * 新平台取代旧平台
    * 法律法规发生变化
    * 系统增长迫使架构变化
    * ...
  * 敏捷开发模式
  * TDD
  * Refactoring

### 本章小结
* 本章探讨了一些关于数据密集型应用的基本思考方式。这些原则将指导我们阅读本书的其余部分，那里将会深入技术细节。
* 一个应用必须满足各种需求才有用
  * 功能性需求
  * 非功能性需求
    * 通用属性
    * 安全性
    * 合规性
    * 兼容性
    * 可靠性(本章内容)
      * 即使发生软件、硬件或人为故障，系统也能正常工作。容错技术可以对终端用户隐藏某些类型的故障。
    * 可扩展性(本章内容)
      * 即使在负载增加的情况下也保持性能的策略
    * 可维护性(本章内容)
      * 同时也是关于工程师和运维团队的生活质量的。良好的抽象可降低复杂度，并使系统易于修改和适应新的应用场景。

## 第二章 数据模型与查询语言

## 第三章 存储与检索

## 第四章 编码与演化

# 第二部分 分布式数据
* 分布在多台机器上的数据，对于可扩展性是必须的，同时带来了许多独特挑战
## 第五章 复制
## 第六章 分区
## 第七章 事务
## 第八章 分布式系统的麻烦
## 第九章 一致性与共识

# 第三部分 衍生数据
* 从其他数据集衍生出一些数据集的系统。衍生数据经常出现在异构系统中，当没有单个数据库可以把所有事情都做的很好时，应用需要集成几种不同的数据库、缓存、索引等。
## 第十章 批处理
## 第十一章 流处理
## 第十二章 数据系统的未来