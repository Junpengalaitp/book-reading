# 第一部分
* 数据密集型应用设计的基本思想

## 第一章 可靠性、可扩展性、可维护性
* 数据密集型应用通常由提供通用功能的标准组件构建而成
  * 存储数据: 数据库
  * 减少昂贵操作的次数：缓存
  * 搜索、过滤数据：搜索索引
  * 跨进程通信：流处理
  * 定期处理累积的大批量数据：批处理


### 关于数据系统的思考
* 新的存储和数据处理工具不断出现，它们针对不同的场景进行优化，因此不在适合生硬地归入传统类别。
  * 缓存Redis可以作为消息队列
  * Kafka消息队列可以向数据库一样持久化消息
* 单个工具不足以满足应用程序的复杂以及严格的要求，总体工作被拆分成一系列能被单个工具高效完成的任务，通过应用代码将它们结合起来。
* 通过API提供多个工具组合后的功能，组合后的工具时一个全新的，专用的数据系统，提供特定的保证。例如缓存在写入时会作废或更新，以便外部客户端获取一致的结果。

#### 可靠性(Reliability)
* 系统在困境(adversity)(硬件、软件故障，人为错误)中仍然可以正常工作(正确完成功能，并达到期望的水准)
* 可靠软件的典型期望
  * 表现出用户所期望的功能
  * 允许用户犯错，允许用户以出乎意料的方式使用软件
  * 在预期的负载和数据量下，性能满足要求
  * 能防止未经授权的访问和滥用
* 故障(fault): 造成错误的原因
* 容错/韧性(fault-tolerant/resilient): 能预料并应对故障的系统特性
* 失效(failure): 故障为系统的部分状态偏离其标准，失效是整个系统停止服务
* 故意触发来提高故障率是有意义的，可以确保容错机制不断运行并接受考验
* 相对于阻止错误，我们应更倾向于容忍错误

#### 硬件故障
* 增加单个硬件的冗余度
#### 软件错误
* 硬件故障一般是随机的、相互独立的，大量硬件组件不太可能同时失效。
* 系统性错误(systematic error)
  * 难以预料、跨节点相关的，可能造成链式失效
  * 接受特定错误输入后导致所有应用服务器实例崩溃的BUG
  * 失控进程会占用一些共享资源
  * 系统依赖的服务变慢或没有正确的响应
  * 级联故障，一个组件中的小故障触发另一个组件中的故障，进而触发更多的故障
* 预防方法
  * 仔细考虑系统中的假设和交互
  * 彻底的测试
  * 进程隔离
  * 允许进程崩溃并重启
  * 测量、监控、并分析生成环境中的系统行为
  * 如果系统能够提供一些保证(例如在一个消息队列中，进入与发出的消息数量相等)，那么系统就可以在运行时不断自检，并在出现差异(discrepancy)时报警。
#### 人为错误
* 以最小化犯错机会的方式设计系统
* 将容易犯错的地方与可能失效的地方解耦，提供一个功能齐全的非生产环境沙箱
* 在各个层次进行彻底的测试
* 允许从人为错误中简单快速地恢复，以最大限度地减少失效情况带来的影响。例如快速回滚配置变更，分批发布新代码，并提供数据重算工具
* 配置详细和明确的监控，比如性能指标和错误率。在其他工程学科中就是遥测(telemetry)
* 良好的管理实践与充分的培训
#### 可靠性有多重要？
* 商务应用中的错误会导致生产力损失（也许数据报告不完整还有法律风险），而电商网站的终端则可能导致收入和声誉的巨大损失。

#### 可扩展性(Scalability)
* 系统现在运行正常，不代表未来也能可靠运行。服务降级(degradation)的一个常见原因是负载增加。

##### 描述负载
* 由合理的办法应对系统的增长(数据量、流量、复杂性)
* 负载参数(load parameters)
  * 每秒Web请求数量
  * 数据库读写比率
  * 同时活跃的用户数量
  * 缓存命中率
  * ...

##### 描述性能
* 增加负载参数并保持系统资源不变时，系统性能收到的影响？
* 增加负载参数并保持性能不变时，需要增加多少系统资源？
* 吞吐量(throughput): 每秒可处理的记录数量，或者在特定规模数据集上运行作业的总时间。通常用在像Hadoop这样的批处理系统上。
* 响应时间(response time): 客户端发送请求到收到响应的时间，通常用于在线系统上。包括网络和排队延时。
  * 响应时间的尾部延时非常重要，因为它直接影响用户体验
    * 响应时间最慢的客户往往是数据最多的客户，也就是最有价值的客户。
    * Amazon观察到：响应时间增加100毫秒，销售量就会减少1%
  * 百分位点通常用于服务基本目标(SLO, service level objectives)和服务级别协议(SLA, service level agreements)
    * 例如服务响应时间的中位数小于200毫秒，且99.9百分位点低于1秒，则认为服务工作正常。
  * 排队延时(queueing delay)通常占了高百分位点处响应时间的很大一部分。由于服务器只能并行处理少量的事务，所以只需少量缓慢请求就能阻塞后续请求的处理(头部阻塞 head-of-line blocking)
* 当一个请求需要多个后端请求组合完成时，单个后端慢请求就会拖慢整个终端用户的请求

##### 应对负载的方法
* 纵向扩展(scaling up)/垂直扩展(vertical scaling)
* 横向扩展(scaling out)/水平扩展(horizontal scaling)
* 弹性扩展：检测到负载时自动增加计算资源
* 一个良好适配应用的可扩展架构，是围绕这假设(assumption)建立的
  * 哪些操作是常见的？
  * 哪些操作是罕见的？


#### 可维护性(Maintainability)
* 不同的人员在不同的周期都能在系统上高效地工作
* 可操作性(Operability)：人生苦短，关爱运维
  * 运维的职责
    * 监控系统运行情况，并在服务状态不佳时快速恢复服务
    * 跟踪问题的原因
    * 及时更新软件和平台
    * 了解系统间相互作用，以便在异常造成损失前进行规避
    * 预测未来问题，并在问题出现之前加以解决(如容量规划)
    * 建立部署，配置和管理方面的良好实践，编写相应工具
    * 执行复杂的维护任务，例如将应用程序跨平台迁移
    * 当配置变更时，维持系统的安全性
    * 定义工作流程，使运维操作可预测，并保持生产环境稳定
    * 维持组织对系统的了解
  * 良好的可操作性意外着更轻松的日常工作，进而运维团队能专注于高价值的事情。数据系统可以通过各种方式使日常任务更轻松
    * 通过良好的监控，提供对系统内部状态和运行时行为的可见性(visibility)
    * 为自动化提供良好支持，将系统与标准化工具相集成
    * 避免依赖单台机器(在整个系统继续不间断运行的情况下允许机器停机维护)
    * 提供良好的文档和易于理解的操作模型
    * 提供良好的默认行为，但也允许管理员自由覆盖默认值
    * 有条件时进行自我修复，但也允许管理员手动控制系统状态
    * 行为可预测，最大限度减少意外

* 简单性(Simplicity)：管理复杂度
  * 消除额外的(accidental)复杂度: 由具体实现中出现，而非用户视角的问题本身复杂度。
  * 使用抽象，好的抽象可以将大量实现细节隐藏在一个干净，简单易懂的外观下面。也可以提升代码的复用性，提高效率。

* 可演化性(evolability)：拥抱变化
  * 系统的需求处于常态的变化中
    * 新的事实
    * 意想不到的应用场景
    * 业务优先级变化
    * 用户要求的新功能
    * 新平台取代旧平台
    * 法律法规发生变化
    * 系统增长迫使架构变化
    * ...
  * 敏捷开发模式
  * TDD
  * Refactoring

### 本章小结
* 本章探讨了一些关于数据密集型应用的基本思考方式。这些原则将指导我们阅读本书的其余部分，那里将会深入技术细节。
* 一个应用必须满足各种需求才有用
  * 功能性需求
  * 非功能性需求
    * 通用属性
    * 安全性
    * 合规性
    * 兼容性
    * 可靠性(本章内容)
      * 即使发生软件、硬件或人为故障，系统也能正常工作。容错技术可以对终端用户隐藏某些类型的故障。
    * 可扩展性(本章内容)
      * 即使在负载增加的情况下也保持性能的策略
    * 可维护性(本章内容)
      * 同时也是关于工程师和运维团队的生活质量的。良好的抽象可降低复杂度，并使系统易于修改和适应新的应用场景。

## 第二章 数据模型与查询语言

### 关系模型与文档模型
#### NoSQL的诞生
#### 对象关系不匹配
#### 多对一和多对多的关系
#### 文档数据库是否在重蹈覆辙？
* 网络模型
* 关系模型
* 与文档数据库相比
#### 关系型数据库与文档数据库在今日的对比
* 哪个数据模型更方便写代码？
* 文档模型中的架构灵活性
* 查询的数据局部性
* 文档和关系数据库的融合
### 数据查询语言
#### Web上的声明式查询
#### MapReduce查询
### 图数据模型
#### 属性图
#### Cypher查询语言
#### SQL中的图查询
#### 三元组存储和SPARQL
* 语义网络
* RDF数据模型
#### SPARQL查询语言
#### 基础：Datalog
* 数据模型可能是软件开发中最重要的部分了，因为它们的影响如此深远：不仅仅影响着软件的编写⽅
式，⽽且影响着我们的解题思路。
* 多数应⽤使⽤层层叠加的数据模型构建。对于每层数据模型的关键问题是：它是如何⽤低⼀层数据模型
来表示的？
  * 作为⼀名应⽤开发⼈员，你观察现实世界（⾥⾯有⼈员，组织，货物，⾏为，资⾦流向，传感器
等），并采⽤对象或数据结构，以及操控那些数据结构的API来进⾏建模。那些结构通常是特定于
应⽤程序的。
  * 当要存储那些数据结构时，你可以利⽤通⽤数据模型来表示它们，如JSON或XML⽂档，关系数据
库中的表、或图模型。
  * 数据库软件的⼯程师选定如何以内存、磁盘或⽹络上的字节来表示JSON/XML/关系/图数据。这类
表示形式使数据有可能以各种⽅式来查询，搜索，操纵和处理。
  * 在更低的层次上，硬件⼯程师已经想出了使⽤电流，光脉冲，磁场或者其他东⻄来表示字节的⽅
法。
* ⼀个复杂的应⽤程序可能会有更多的中间层次，⽐如基于API的API，不过基本思想仍然是⼀样的：每个
层都通过提供⼀个明确的数据模型来隐藏更低层次中的复杂性。这些抽象允许不同的⼈群有效地协作。
* 掌握⼀个数据模型需要花费很多精⼒（想想关系数据建模有多少本书）。即便只使⽤⼀个数据模型，不
⽤操⼼其内部⼯作机制，构建软件也是⾮常困难的。然⽽，因为数据模型对上层软件的功能（能做什
么，不能做什么）有着⾄深的影响，所以选择⼀个适合的数据模型是⾮常重要的。

### 关系模型与⽂档模型
* 现在最著名的数据模型可能是SQL。它基于Edgar Codd在1970年提出的关系模型【1】：数据被组织成
关系（SQL中称作表），其中每个关系是元组（SQL中称作⾏)的⽆序集合。

#### NoSQL的诞⽣
* 需要比关系型数据库更好的扩展性，包括非常大的数据集或非常高的写入吞吐量
* 免费和开源
* 关系模型不能很好地支持一些特殊的查询
* 受挫于关系模型的限制性，渴望一种更具多动态性与表现力的数据模型
##### 混合持久化
* SQL和NoSQL混用

#### 对象关系不匹配
* 阻抗不匹配(impedance mismatch): 面向对象的代码存储在SQL表中需要一个笨拙的转换层。
* 对于⼀个像简历这样⾃包含⽂档的数据结构⽽⾔，JSON表示是⾮常合适的：参⻅例2-1。JSON⽐XML更
简单。⾯向⽂档的数据库（如MongoDB，RethinkDB，CouchDB和
Espresso）⽀持这种数据模型。

#### 多对⼀和多对多的关系
* 使用id而不是实际文本的好处
  * 各个简介之间样式和拼写统⼀
  * 避免歧义（例如，如果有⼏个同名的城市）
  * 易于更新——名称只存储在⼀个地⽅，如果需要更改（例如，由于政治事件⽽改变城市名称），很容易进⾏全⾯更新。
  * 本地化⽀持——当⽹站翻译成其他语⾔时，标准化的列表可以被本地化，使得地区和⾏业可以使⽤⽤户的语⾔来显示
  * 更好的搜索——例如，搜索华盛顿州的慈善家就会匹配这份简介，因为地区列表可以编码记录⻄雅图在华盛顿这⼀事实（从"Greater Seattle Area"这个字符串中看不出来）。
* 存储ID还是⽂本字符串，这是个副本（duplication）问题。当使⽤ID时，对⼈类有意义的信息（⽐如
单词：Philanthropy）只存储在⼀处，所有引⽤它的地⽅使⽤ID（ID只在数据库中有意义）。当直接存
储⽂本时，对⼈类有意义的信息会复制在每处使⽤记录中。
* 使⽤ID的好处是，ID对⼈类没有任何意义，因⽽永远不需要改变：ID可以保持不变，即使它标识的信息
发⽣变化。任何对⼈类有意义的东⻄都可能需要在将来某个时候改变——如果这些信息被复制，所有的
冗余副本都需要更新。这会导致写⼊开销，也存在不⼀致的⻛险（⼀些副本被更新了，还有些副本没有
被更新）。去除此类重复是数据库规范化（normalization）的关键思想。

#### ⽂档数据库是否在重蹈覆辙？
#### 关系型数据库与⽂档数据库在今⽇的对⽐
##### 哪个数据模型更⽅便写代码？
* 如果应⽤程序中的数据具有类似⽂档的结构（即，⼀对多关系树，通常⼀次性加载整个树），那么使⽤
⽂档模型可能是⼀个好主意。将类似⽂档的结构分解成多个表的关系技术可能导致繁琐的模式和不必要的复杂的应⽤程序代码。
* 但是，如果你的应⽤程序确实使⽤多对多关系，那么⽂档模型就没有那么吸引⼈了。通过反规范化可以
减少对连接的需求，但是应⽤程序代码需要做额外的⼯作来保持数据的⼀致性。
* 很难说在⼀般情况下哪个数据模型让应⽤程序代码更简单；它取决于数据项之间存在的关系种类。对于
⾼度相联的数据，选⽤⽂档模型是糟糕的，选⽤关系模型是可接受的，⽽选⽤图形模型是最⾃然的。
##### ⽂档模型中的架构灵活性
* ⼤多数⽂档数据库以及关系数据库中的JSON⽀持都不会强制⽂档中的数据采⽤何种模式。关系数据库的
XML⽀持通常带有可选的模式验证。没有模式意味着可以将任意的键和值添加到⽂档中，并且当读取
时，客户端对⽆法保证⽂档可能包含的字段。
* ⽂档数据库有时称为⽆模式（schemaless），但这具有误导性，因为读取数据的代码通常假定某种结
构——即存在隐式模式，但不由数据库强制执⾏。⼀个更精确的术语是读时模式（schema-on-read）（数据的结构是隐含的，只有在数据被读取时才被解释），相应的是写时模式（schema-on-write）（传统的关系数据库⽅法中，模式明确，且数据库确保所有的数据都符合其模式）
* 当由于某种原因（例如，数据是异构的）集合中的项⽬并不都具有相同的结构时,读时模式更具优势
  * 存在许多不同类型的对象，将每种类型的对象放在⾃⼰的表中是不现实的。
  * 数据的结构由外部系统决定。你⽆法控制外部系统且它随时可能变化。
##### 查询的数据局部性
* ⽂档通常以单个连续字符串形式进⾏存储，编码为JSON，XML或其⼆进制变体（如MongoDB的
BSON）。如果应⽤程序经常需要访问整个⽂档（例如，将其渲染⾄⽹⻚），那么存储局部性会带来性
能优势。如果将数据分割到多个表中（如图2-1所示），则需要进⾏多次索引查找才能将其全部检索出
来，这可能需要更多的磁盘查找并花费更多的时间。
* 局部性仅仅适⽤于同时需要⽂档绝⼤部分内容的情况。数据库通常需要加载整个⽂档，即使只访问其中
的⼀⼩部分，这对于⼤型⽂档来说是很浪费的。更新⽂档时，通常需要整个重写。只有不改变⽂档⼤⼩
的修改才可以容易地原地执⾏。因此，通常建议保持相对⼩的⽂档，并避免增加⽂档⼤⼩的写⼊。这些性能限制⼤⼤减少了⽂档数据库的实⽤场景。

##### ⽂档和关系数据库的融合

### 数据查询语⾔
#### Web上的声明式查询
#### MapReduce查询
* MapReduce既不是⼀个声明式的查询语⾔，也不是⼀个完全命令式的查询API，⽽是处于两者之间：查
询的逻辑⽤代码⽚断来表示，这些代码⽚段会被处理框架重复性调⽤。它基于 map （也称
为 collect ）和 reduce （也称为 fold 或 inject ）函数，两个函数存在于许多函数式编程语⾔中。

### 图数据模型
#### 属性图
* 在属性图模型中，每个顶点（vertex）包括：
  * 唯⼀的标识符
  * ⼀组出边（outgoing edges）
  * ⼀组⼊边（ingoing edges）
  * ⼀组属性（键值对）
* 每条边（edge）包括：
  * 唯⼀标识符
  * 边的起点/尾部顶点（tail vertex）
  * 边的终点/头部顶点（head vertex）
  * 描述两个顶点之间关系类型的标签
  * ⼀组属性（键值对）
* 重要特性
  * 任何顶点都可以有⼀条边连接到任何其他顶点。没有模式限制哪种事物可不可以关联。
  * 给定任何顶点，可以⾼效地找到它的⼊边和出边，从⽽遍历图，即沿着⼀系列顶点的路径前后移
动。
  * 通过对不同类型的关系使⽤不同的标签，可以在⼀个图中存储⼏种不同的信息，同时仍然保持⼀个
清晰的数据模型。

#### Cypher查询语⾔
#### SQL中的图查询
#### 三元组存储和SPARQL
* 在三元组存储中，所有信息都以⾮常简单的三部分表示形式存储（主语，谓语，宾语）。例如，三元组
(吉姆, 喜欢 ,⾹蕉)中，吉姆是主语，喜欢是谓语（动词），⾹蕉是对象。
* 三元组的主语相当于图中的⼀个顶点。⽽宾语是下⾯两者之⼀：
  1. 原始数据类型中的值，例如字符串或数字。在这种情况下，三元组的谓语和宾语相当于主语顶点上
  的属性的键和值。例如， (lucy, age, 33) 就像属性 {“age”：33} 的顶点lucy。
  2. 图中的另⼀个顶点。在这种情况下，谓语是图中的⼀条边，主语是其尾部顶点，⽽宾语是其头部顶
  点。例如，在 (lucy, marriedTo, alain) 中主语和宾语 lucy 和 alain 都是顶点，并且谓语
  marriedTo 是连接他们的边的标签。
#### 语义⽹络
#### RDF数据模型
#### SPARQL查询语⾔

### 本章⼩结
数据模型是⼀个巨⼤的课题，在本章中，我们快速浏览了各种不同的模型。我们没有⾜够的空间来详细
介绍每个模型的细节，但是希望这个概述⾜以激起你的兴趣，以更多地了解最适合你的应⽤需求的模
型。
在历史上，数据最开始被表示为⼀棵⼤树（层次数据模型），但是这不利于表示多对多的关系，所以发
明了关系模型来解决这个问题。最近，开发⼈员发现⼀些应⽤程序也不适合采⽤关系模型。新的⾮关系
型“NoSQL”数据存储在两个主要⽅向上存在分歧：
1. ⽂档数据库的应⽤场景是：数据通常是⾃我包含的，⽽且⽂档之间的关系⾮常稀少。
2. 图形数据库⽤于相反的场景：任意事物都可能与任何事物相关联。
这三种模型（⽂档，关系和图形）在今天都被⼴泛使⽤，并且在各⾃的领域都发挥很好。⼀个模型可以
⽤另⼀个模型来模拟 — 例如，图数据可以在关系数据库中表示 — 但结果往往是糟糕的。这就是为什么
我们有着针对不同⽬的的不同系统，⽽不是⼀个单⼀的万能解决⽅案。
⽂档数据库和图数据库有⼀个共同点，那就是它们通常不会为存储的数据强制⼀个模式，这可以使应⽤
程序更容易适应不断变化的需求。但是应⽤程序很可能仍会假定数据具有⼀定的结构；这只是模式是明
确的（写⼊时强制）还是隐含的（读取时处理）的问题。
每个数据模型都具有各⾃的查询语⾔或框架，我们讨论了⼏个例⼦：SQL，MapReduce，MongoDB的
聚合管道，Cypher，SPARQL和Datalog。我们也谈到了CSS和XSL/XPath，它们不是数据库查询语⾔，
⽽包含有趣的相似之处。
虽然我们已经覆盖了很多层⾯，但仍然有许多数据模型没有提到。举⼏个简单的例⼦：
使⽤基因组数据的研究⼈员通常需要执⾏序列相似性搜索，这意味着需要⼀个很⻓的字符串（代表
⼀个DNA分⼦），并在⼀个拥有类似但不完全相同的字符串的⼤型数据库中寻找匹配。这⾥所描
述的数据库都不能处理这种⽤法，这就是为什么研究⼈员编写了像GenBank这样的专⻔的基因组
数据库软件的原因【48】。
粒⼦物理学家数⼗年来⼀直在进⾏⼤数据类型的⼤规模数据分析，像⼤型强⼦对撞机（LHC）这样
的项⽬现在可以⼯作在数百亿兆字节的范围内！在这样的规模下，需要定制解决⽅案来阻住硬件成
本的失控【49】。
全⽂搜索可以说是⼀种经常与数据库⼀起使⽤的数据模型。信息检索是⼀个很⼤的专业课题，我们
不会在本书中详细介绍，但是我们将在第三章和第三章中介绍搜索索引

## 第三章 存储与检索

## 第四章 编码与演化

# 第二部分 分布式数据
* 分布在多台机器上的数据，对于可扩展性是必须的，同时带来了许多独特挑战
## 第五章 复制
## 第六章 分区
## 第七章 事务
## 第八章 分布式系统的麻烦
## 第九章 一致性与共识

# 第三部分 衍生数据
* 从其他数据集衍生出一些数据集的系统。衍生数据经常出现在异构系统中，当没有单个数据库可以把所有事情都做的很好时，应用需要集成几种不同的数据库、缓存、索引等。
## 第十章 批处理
## 第十一章 流处理
## 第十二章 数据系统的未来